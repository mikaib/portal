// Generated by Haxe 4.3.6
#ifndef INCLUDED_genesis__Genesis
#define INCLUDED_genesis__Genesis

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

#ifndef INCLUDED_4dbe585c96d08098
#define INCLUDED_4dbe585c96d08098
#include "genesis.h"
#endif
HX_DECLARE_CLASS1(genesis,_Genesis)
HX_DECLARE_CLASS2(genesis,_GsManagedData,GsManagedDataHolder)
HX_DECLARE_CLASS2(haxe,io,Bytes)

namespace genesis{


class HXCPP_CLASS_ATTRIBUTES _Genesis_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef _Genesis_obj OBJ_;
		_Genesis_obj();

	public:
		enum { _hx_ClassId = 0x7ff86a2d };

		void __construct();
		inline void *operator new(size_t inSize, bool inContainer=false,const char *inName="genesis._Genesis")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,false,"genesis._Genesis"); }

		inline static ::hx::ObjectPtr< _Genesis_obj > __new() {
			::hx::ObjectPtr< _Genesis_obj > __this = new _Genesis_obj();
			__this->__construct();
			return __this;
		}

		inline static ::hx::ObjectPtr< _Genesis_obj > __alloc(::hx::Ctx *_hx_ctx) {
			_Genesis_obj *__this = (_Genesis_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(_Genesis_obj), false, "genesis._Genesis"));
			*(void **)__this = _Genesis_obj::_hx_vtable;
			return __this;
		}

		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~_Genesis_obj();

		HX_DO_RTTI_ALL;
		static void __register();
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("_Genesis",c9,b5,65,bd); }

		static bool layoutAdd( GsVtxLayout * layout,int index, cpp::Struct<GsVtxAttribType> type,int count);

		static void layoutBuild( GsVtxLayout * layout);

		static bool init( GsConfig * config);

		static void shutdown();

		static  GsConfig * createConfig();

		static  GsBackend * createBackend( cpp::Struct<GsBackendType> type);

		static  GsVtxLayout * createLayout();

		static void destroyConfig( GsConfig * config);

		static void destroyBackend( GsBackend * backend);

		static void destroyLayout( GsVtxLayout * layout);

		static  cpp::Struct<GsBackendType> getOptimalBackendType();

		static  GsCommandList * createCommandList();

		static void destroyCommandList( GsCommandList * list);

		static void commandListClear( GsCommandList * list);

		static void commandListBegin( GsCommandList * list);

		static void commandListEnd( GsCommandList * list);

		static void commandListSubmit( GsCommandList * list);

		static void clear( GsCommandList * list,int flags,Float r,Float g,Float b,Float a);

		static void setViewport( GsCommandList * list,int x,int y,int width,int height);

		static void usePipeline( GsCommandList * list, GsPipeline * pipeline);

		static void useBuffer( GsCommandList * list, GsBuffer * buffer);

		static void useTexture( GsCommandList * list, GsTexture * texture,int slot);

		static void frame();

		static void discardFrame();

		static  GsPipeline * createPipeline();

		static void destroyPipeline( GsPipeline * pipeline);

		static void pipelineSetLayout( GsPipeline * pipeline, GsVtxLayout * layout);

		static  GsBuffer * createBuffer( cpp::Struct<GsBufferType> type, cpp::Struct<GsBufferIntent> intent);

		static void destroyBuffer( GsBuffer * buffer);

		static void bufferSetData( GsBuffer * buffer, ::genesis::_GsManagedData::GsManagedDataHolder data);

		static void bufferSetPartialData( GsBuffer * buffer, ::genesis::_GsManagedData::GsManagedDataHolder data,int offset);

		static void destroyUnmanagedBufferData( GsUnmanagedBufferData * data);

		static void drawArrays( GsCommandList * list,int start,int count);

		static void drawIndexed( GsCommandList * list,int count);

		static void setScissor( GsCommandList * list,int x,int y,int width,int height);

		static void disableScissor( GsCommandList * list);

		static  GsShader * createShader( cpp::Struct<GsShaderType> type,const char* source);

		static void destroyShader( GsShader * shader);

		static  GsProgram * createProgram();

		static void programAttachShader( GsProgram * program, GsShader * shader);

		static void programBuild( GsProgram * program);

		static void destroyProgram( GsProgram * program);

		static void _createMainloop(::cpp::Function< void  () > fn);

		static void startMainloop( ::Dynamic fn);

		static void stopMainloop();

		static  GsTexture * createTexture(int width,int height, cpp::Struct<GsTextureFormat> format, cpp::Struct<GsTextureWrap> wrapS, cpp::Struct<GsTextureWrap> wrapT, cpp::Struct<GsTextureFilter> min, cpp::Struct<GsTextureFilter> mag);

		static  GsTexture * createTextureSimple(int width,int height, cpp::Struct<GsTextureFormat> format);

		static  GsTexture * createCubemap(int width,int height, cpp::Struct<GsTextureFormat> format, cpp::Struct<GsTextureWrap> wrapS, cpp::Struct<GsTextureWrap> wrapT, cpp::Struct<GsTextureWrap> wrapR, cpp::Struct<GsTextureFilter> min, cpp::Struct<GsTextureFilter> mag);

		static void textureSetData( GsTexture * texture, ::haxe::io::Bytes data);

		static void textureSetFaceData( GsTexture * texture, cpp::Struct<GsCubemapFace> face, ::haxe::io::Bytes data);

		static void textureGenerateMipmaps( GsTexture * texture);

		static void destroyTexture( GsTexture * texture);

		static int getUniformLocation( GsProgram * program,const char* name);

		static void uniformSetInt( GsCommandList * list,int location,int value);

		static void uniformSetFloat( GsCommandList * list,int location,float value);

		static void uniformSetVec2( GsCommandList * list,int location,float x,float y);

		static void uniformSetVec3( GsCommandList * list,int location,float x,float y,float z);

		static void uniformSetVec4( GsCommandList * list,int location,float x,float y,float z,float w);

		static void uniformSetMat4( GsCommandList * list,int location,float m00,float m01,float m02,float m03,float m10,float m11,float m12,float m13,float m20,float m21,float m22,float m23,float m30,float m31,float m32,float m33);

		static void copyTexture( GsCommandList * list, GsTexture * src, GsTexture * dst);

		static void resolveTexture( GsCommandList * list, GsTexture * src, GsTexture * dst);

		static void copyTexturePartial( GsCommandList * list, GsTexture * src, GsTexture * dst,int srcX,int srcY,int dstX,int dstY,int width,int height);

		static void generateMipmaps( GsCommandList * list, GsTexture * texture);

		static  GsRenderPass * createRenderPass( GsFramebuffer * fb);

		static void destroyRenderPass( GsRenderPass * pass);

		static void beginRenderPass( GsCommandList * list, GsRenderPass * pass);

		static void endRenderPass( GsCommandList * list);

		static int hasCapability( cpp::Struct<GsCapability> cap);

		static void textureClear( GsTexture * texture);

		static  GsFramebuffer * createFramebuffer(int width,int height);

		static void destroyFramebuffer( GsFramebuffer * fb);

		static void framebufferAttachTexture( GsFramebuffer * fb, GsTexture * texture, cpp::Struct<GsFramebufferAttachmentType> attachment);

};

} // end namespace genesis

#endif /* INCLUDED_genesis__Genesis */ 
