// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_4dbe585c96d08098
#define INCLUDED_4dbe585c96d08098
#include "genesis.h"
#endif
#ifndef INCLUDED_0dc8763c2770302b
#define INCLUDED_0dc8763c2770302b
#include "portal.h"
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_genesis_GsMainloop
#include <genesis/GsMainloop.h>
#endif
#ifndef INCLUDED_genesis__GsManagedData_GsManagedDataHolder
#include <genesis/_GsManagedData/GsManagedDataHolder.h>
#endif
#ifndef INCLUDED_genesis__GsManagedData_GsManagedData_Impl_
#include <genesis/_GsManagedData/GsManagedData_Impl_.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e47a9afac0942eb9_16_new,"Main","new",0x6616a5cb,"Main.new","Main.hx",16,0x087e5c05)
static const int _hx_array_data_332f6459_1[] = {
	(int)0,(int)1,(int)2,
};
static const float _hx_array_data_332f6459_2[] = {
	0.0,0.5,0.0,1.0,0.0,0.0,1.0,-0.5,-0.5,0.0,0.0,1.0,0.0,1.0,0.5,-0.5,0.0,0.0,0.0,1.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_93_initWindow,"Main","initWindow",0xee596d15,"Main.initWindow","Main.hx",93,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_106_destroyWindow,"Main","destroyWindow",0xf8fc15b5,"Main.destroyWindow","Main.hx",106,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_111_initGraphics,"Main","initGraphics",0xddf92530,"Main.initGraphics","Main.hx",111,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_156_destroyGraphics,"Main","destroyGraphics",0xd50f35d0,"Main.destroyGraphics","Main.hx",156,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_175_frame,"Main","frame",0x82b6be58,"Main.frame","Main.hx",175,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_187_loop,"Main","loop",0xec6f8e99,"Main.loop","Main.hx",187,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_215_init,"Main","init",0xea732345,"Main.init","Main.hx",215,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_222_destroy,"Main","destroy",0x88b793e5,"Main.destroy","Main.hx",222,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_228_main,"Main","main",0xed0e206e,"Main.main","Main.hx",228,0x087e5c05)

void Main_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_16_new)
HXLINE(  91)		this->isActive = true;
HXLINE(  65)		this->fragmentShaderSource = HX_("\r\n        #version 460 core\r\n\r\n        in vec4 vColour;\r\n        out vec4 fragColor;\r\n\r\n        void main() {\r\n            fragColor = vColour;\r\n        }\r\n    ",32,6c,02,04);
HXLINE(  52)		this->vertexShaderSource = HX_("\r\n        #version 460 core\r\n\r\n        layout(location = 0) in vec3 aPosition;\r\n        layout(location = 1) in vec4 aColour;\r\n        out vec4 vColour;\r\n\r\n        void main() {\r\n            gl_Position = vec4(aPosition, 1.0);\r\n            vColour = aColour;\r\n        }\r\n    ",75,d8,05,d8);
HXLINE(  25)		this->indexData = ::Array_obj< int >::fromData( _hx_array_data_332f6459_1,3);
HXLINE(  18)		this->vertexData = ::Array_obj< float >::fromData( _hx_array_data_332f6459_2,21);
            	}

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x07825a7d;
}

void Main_obj::initWindow(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_93_initWindow)
HXLINE(  94)		::haxe::Log_obj::trace(HX_("Hello from Genesis!",a1,72,54,c7),::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),94,HX_("Main",59,64,2f,33),HX_("initWindow",20,ef,d1,56)));
HXLINE(  95)		this->ptBackend = pt_create_backend(pt_get_optimal_backend_type());
HXLINE(  97)		this->ptConfig = pt_create_config();
HXLINE(  98)		(*(this->ptConfig)).backend = this->ptBackend;
HXLINE( 100)		pt_init(this->ptConfig);
HXLINE( 102)		this->window = pt_create_window(HX_("Genesis [1 - Hello Triangle]",82,bf,f6,eb),600,600);
HXLINE( 103)		pt_use_gl_context(this->window);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,initWindow,(void))

void Main_obj::destroyWindow(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_106_destroyWindow)
HXLINE( 107)		pt_destroy_window(this->window);
HXLINE( 108)		pt_shutdown();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,destroyWindow,(void))

void Main_obj::initGraphics(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_111_initGraphics)
HXLINE( 113)		this->backend = gs_create_backend(gs_get_optimal_backend_type());
HXLINE( 116)		this->config = gs_create_config();
HXLINE( 117)		(*(this->config)).backend = this->backend;
HXLINE( 120)		gs_init(this->config);
HXLINE( 123)		this->commandList = gs_create_command_list();
HXLINE( 126)		this->vertexShader = gs_create_shader(GS_SHADER_TYPE_VERTEX,this->vertexShaderSource.utf8_str());
HXLINE( 127)		this->fragmentShader = gs_create_shader(GS_SHADER_TYPE_FRAGMENT,this->fragmentShaderSource.utf8_str());
HXLINE( 130)		this->program = gs_create_program();
HXLINE( 131)		gs_program_attach_shader(this->program,this->vertexShader);
HXLINE( 132)		gs_program_attach_shader(this->program,this->fragmentShader);
HXLINE( 133)		gs_program_build(this->program);
HXLINE( 136)		this->layout = gs_create_layout();
HXLINE( 137)		{
HXLINE( 137)			 GsVtxLayout * _this = this->layout;
HXDLIN( 137)			gs_layout_add(_this,0,GS_ATTRIB_TYPE_FLOAT,3);
            		}
HXLINE( 138)		{
HXLINE( 138)			 GsVtxLayout * _this1 = this->layout;
HXDLIN( 138)			gs_layout_add(_this1,1,GS_ATTRIB_TYPE_FLOAT,4);
            		}
HXLINE( 139)		gs_layout_build(this->layout);
HXLINE( 142)		this->pipeline = gs_create_pipeline();
HXLINE( 143)		(*(this->pipeline)).layout = this->layout;
HXLINE( 144)		(*(this->pipeline)).program = this->program;
HXLINE( 145)		(*(this->pipeline)).msaa_samples = 4;
HXLINE( 148)		this->vertexBuffer = gs_create_buffer(GS_BUFFER_TYPE_VERTEX,GS_BUFFER_INTENT_DRAW_STATIC);
HXLINE( 149)		{
HXLINE( 149)			 GsBuffer * _this2 = this->vertexBuffer;
HXDLIN( 149)			::Array< float > data = this->vertexData;
HXDLIN( 149)			::cpp::Pointer< void > ptr = ( (::cpp::Pointer< float >)(::cpp::Pointer_obj::arrayElem(data,0)) )->reinterpret();
HXDLIN( 149)			 ::genesis::_GsManagedData::GsManagedDataHolder data1 = ::genesis::_GsManagedData::GsManagedData_Impl__obj::_new(ptr->ptr,(data->length * 4));
HXDLIN( 149)			gs_buffer_set_data(_this2,data1->ptr,data1->size);
            		}
HXLINE( 152)		this->indexBuffer = gs_create_buffer(GS_BUFFER_TYPE_INDEX,GS_BUFFER_INTENT_DRAW_STATIC);
HXLINE( 153)		{
HXLINE( 153)			 GsBuffer * _this3 = this->indexBuffer;
HXDLIN( 153)			::Array< int > data2 = this->indexData;
HXDLIN( 153)			::cpp::Pointer< void > ptr1 = ( (::cpp::Pointer< int >)(::cpp::Pointer_obj::arrayElem(data2,0)) )->reinterpret();
HXDLIN( 153)			 ::genesis::_GsManagedData::GsManagedDataHolder data3 = ::genesis::_GsManagedData::GsManagedData_Impl__obj::_new(ptr1->ptr,(data2->length * 4));
HXDLIN( 153)			gs_buffer_set_data(_this3,data3->ptr,data3->size);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,initGraphics,(void))

void Main_obj::destroyGraphics(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_156_destroyGraphics)
HXLINE( 158)		gs_destroy_command_list(this->commandList);
HXLINE( 159)		gs_destroy_pipeline(this->pipeline);
HXLINE( 160)		gs_destroy_layout(this->layout);
HXLINE( 161)		gs_destroy_buffer(this->vertexBuffer);
HXLINE( 162)		gs_destroy_buffer(this->indexBuffer);
HXLINE( 163)		gs_destroy_shader(this->vertexShader);
HXLINE( 164)		gs_destroy_shader(this->fragmentShader);
HXLINE( 165)		gs_destroy_program(this->program);
HXLINE( 168)		gs_shutdown();
HXLINE( 171)		gs_destroy_backend(this->backend);
HXLINE( 172)		gs_destroy_config(this->config);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,destroyGraphics,(void))

void Main_obj::frame(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_175_frame)
HXLINE( 176)		{
HXLINE( 176)			 GsCommandList * _this = this->commandList;
HXDLIN( 176)			gs_command_list_begin(_this);
            		}
HXLINE( 177)		{
HXLINE( 177)			 GsCommandList * _this1 = this->commandList;
HXDLIN( 177)			int width = pt_get_window_width(this->window);
HXDLIN( 177)			gs_set_viewport(_this1,0,0,width,pt_get_window_height(this->window));
            		}
HXLINE( 178)		{
HXLINE( 178)			 GsCommandList * _this2 = this->commandList;
HXDLIN( 178)			gs_clear(_this2,(GsClearFlags)(1 | 2),( (Float)(0) ),( (Float)(0) ),( (Float)(0) ),( (Float)(1) ));
            		}
HXLINE( 179)		{
HXLINE( 179)			 GsCommandList * _this3 = this->commandList;
HXDLIN( 179)			gs_use_pipeline(_this3,this->pipeline);
            		}
HXLINE( 180)		{
HXLINE( 180)			 GsCommandList * _this4 = this->commandList;
HXDLIN( 180)			gs_use_buffer(_this4,this->vertexBuffer);
            		}
HXLINE( 181)		{
HXLINE( 181)			 GsCommandList * _this5 = this->commandList;
HXDLIN( 181)			gs_use_buffer(_this5,this->indexBuffer);
            		}
HXLINE( 182)		{
HXLINE( 182)			 GsCommandList * _this6 = this->commandList;
HXDLIN( 182)			gs_draw_indexed(_this6,3);
            		}
HXLINE( 183)		{
HXLINE( 183)			 GsCommandList * _this7 = this->commandList;
HXDLIN( 183)			gs_command_list_end(_this7);
            		}
HXLINE( 184)		{
HXLINE( 184)			 GsCommandList * _this8 = this->commandList;
HXDLIN( 184)			gs_command_list_submit(_this8);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,frame,(void))

void Main_obj::loop(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_187_loop)
HXLINE( 188)		if ((pt_should_be_active(this->window) != 1)) {
HXLINE( 189)			if (this->isActive) {
HXLINE( 190)				this->isActive = false;
HXLINE( 191)				pt_deactivate(this->window);
HXLINE( 192)				::haxe::Log_obj::trace(HX_("Window deactivated",a0,e5,b1,11),::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),192,HX_("Main",59,64,2f,33),HX_("loop",64,a6,b7,47)));
            			}
HXLINE( 195)			::Sys_obj::sleep(((Float)0.1));
HXLINE( 196)			return;
            		}
            		else {
HXLINE( 197)			if (!(this->isActive)) {
HXLINE( 198)				this->isActive = true;
HXLINE( 199)				pt_activate(this->window);
HXLINE( 200)				::haxe::Log_obj::trace(HX_("Window activated",41,d9,dc,35),::hx::SourceInfo(HX_("Source/Main.hx",b1,67,fd,ea),200,HX_("Main",59,64,2f,33),HX_("loop",64,a6,b7,47)));
            			}
            		}
HXLINE( 203)		if ((pt_should_window_close(this->window) == 1)) {
HXLINE( 204)			this->destroy();
HXLINE( 205)			return;
            		}
HXLINE( 208)		this->frame();
HXLINE( 210)		gs_frame();
HXLINE( 211)		pt_swap_buffers(this->window);
HXLINE( 212)		pt_poll_events(this->window);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,loop,(void))

void Main_obj::init(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_215_init)
HXLINE( 216)		this->initWindow();
HXLINE( 217)		this->initGraphics();
HXLINE( 219)		::genesis::GsMainloop_obj::start(this->loop_dyn());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,init,(void))

void Main_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_222_destroy)
HXLINE( 223)		gs_stop_mainloop();
HXLINE( 224)		this->destroyGraphics();
HXLINE( 225)		this->destroyWindow();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Main_obj,destroy,(void))

void Main_obj::main(){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_228_main)
HXLINE( 229)		 ::Main app =  ::Main_obj::__alloc( HX_CTX );
HXLINE( 230)		app->init();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Main_obj,main,(void))


::hx::ObjectPtr< Main_obj > Main_obj::__new() {
	::hx::ObjectPtr< Main_obj > __this = new Main_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Main_obj > Main_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Main_obj *__this = (Main_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Main_obj), true, "Main"));
	*(void **)__this = Main_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Main_obj::Main_obj()
{
}

void Main_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Main);
	HX_MARK_MEMBER_NAME(vertexData,"vertexData");
	HX_MARK_MEMBER_NAME(indexData,"indexData");
	HX_MARK_MEMBER_NAME(vertexShaderSource,"vertexShaderSource");
	HX_MARK_MEMBER_NAME(fragmentShaderSource,"fragmentShaderSource");
	HX_MARK_MEMBER_NAME(window,"window");
	HX_MARK_MEMBER_NAME(ptConfig,"ptConfig");
	HX_MARK_MEMBER_NAME(ptBackend,"ptBackend");
	HX_MARK_MEMBER_NAME(backend,"backend");
	HX_MARK_MEMBER_NAME(config,"config");
	HX_MARK_MEMBER_NAME(commandList,"commandList");
	HX_MARK_MEMBER_NAME(pipeline,"pipeline");
	HX_MARK_MEMBER_NAME(layout,"layout");
	HX_MARK_MEMBER_NAME(program,"program");
	HX_MARK_MEMBER_NAME(vertexShader,"vertexShader");
	HX_MARK_MEMBER_NAME(fragmentShader,"fragmentShader");
	HX_MARK_MEMBER_NAME(vertexBuffer,"vertexBuffer");
	HX_MARK_MEMBER_NAME(indexBuffer,"indexBuffer");
	HX_MARK_MEMBER_NAME(isActive,"isActive");
	HX_MARK_END_CLASS();
}

void Main_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(vertexData,"vertexData");
	HX_VISIT_MEMBER_NAME(indexData,"indexData");
	HX_VISIT_MEMBER_NAME(vertexShaderSource,"vertexShaderSource");
	HX_VISIT_MEMBER_NAME(fragmentShaderSource,"fragmentShaderSource");
	HX_VISIT_MEMBER_NAME(window,"window");
	HX_VISIT_MEMBER_NAME(ptConfig,"ptConfig");
	HX_VISIT_MEMBER_NAME(ptBackend,"ptBackend");
	HX_VISIT_MEMBER_NAME(backend,"backend");
	HX_VISIT_MEMBER_NAME(config,"config");
	HX_VISIT_MEMBER_NAME(commandList,"commandList");
	HX_VISIT_MEMBER_NAME(pipeline,"pipeline");
	HX_VISIT_MEMBER_NAME(layout,"layout");
	HX_VISIT_MEMBER_NAME(program,"program");
	HX_VISIT_MEMBER_NAME(vertexShader,"vertexShader");
	HX_VISIT_MEMBER_NAME(fragmentShader,"fragmentShader");
	HX_VISIT_MEMBER_NAME(vertexBuffer,"vertexBuffer");
	HX_VISIT_MEMBER_NAME(indexBuffer,"indexBuffer");
	HX_VISIT_MEMBER_NAME(isActive,"isActive");
}

::hx::Val Main_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"loop") ) { return ::hx::Val( loop_dyn() ); }
		if (HX_FIELD_EQ(inName,"init") ) { return ::hx::Val( init_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"frame") ) { return ::hx::Val( frame_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isActive") ) { return ::hx::Val( isActive ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"indexData") ) { return ::hx::Val( indexData ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"vertexData") ) { return ::hx::Val( vertexData ); }
		if (HX_FIELD_EQ(inName,"initWindow") ) { return ::hx::Val( initWindow_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"initGraphics") ) { return ::hx::Val( initGraphics_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"destroyWindow") ) { return ::hx::Val( destroyWindow_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"destroyGraphics") ) { return ::hx::Val( destroyGraphics_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"vertexShaderSource") ) { return ::hx::Val( vertexShaderSource ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"fragmentShaderSource") ) { return ::hx::Val( fragmentShaderSource ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Main_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"main") ) { outValue = main_dyn(); return true; }
	}
	return false;
}

::hx::Val Main_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"isActive") ) { isActive=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"indexData") ) { indexData=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"vertexData") ) { vertexData=inValue.Cast< ::Array< float > >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"vertexShaderSource") ) { vertexShaderSource=inValue.Cast< ::String >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"fragmentShaderSource") ) { fragmentShaderSource=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Main_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("vertexData",ae,df,1f,d3));
	outFields->push(HX_("indexData",5c,0e,71,fe));
	outFields->push(HX_("vertexShaderSource",64,fb,81,44));
	outFields->push(HX_("fragmentShaderSource",d0,71,8a,f6));
	outFields->push(HX_("window",f0,93,8c,52));
	outFields->push(HX_("ptConfig",e6,87,32,da));
	outFields->push(HX_("ptBackend",70,8a,52,fd));
	outFields->push(HX_("backend",14,bc,87,fb));
	outFields->push(HX_("config",c2,56,d2,c7));
	outFields->push(HX_("commandList",49,bb,13,e5));
	outFields->push(HX_("pipeline",22,bb,83,4b));
	outFields->push(HX_("layout",aa,ae,b8,58));
	outFields->push(HX_("program",84,4a,f9,f3));
	outFields->push(HX_("vertexShader",a9,b1,35,bd));
	outFields->push(HX_("fragmentShader",15,4f,dc,39));
	outFields->push(HX_("vertexBuffer",84,af,a9,70));
	outFields->push(HX_("indexBuffer",b2,65,a6,f5));
	outFields->push(HX_("isActive",50,dd,af,6e));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Main_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< float > */ ,(int)offsetof(Main_obj,vertexData),HX_("vertexData",ae,df,1f,d3)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Main_obj,indexData),HX_("indexData",5c,0e,71,fe)},
	{::hx::fsString,(int)offsetof(Main_obj,vertexShaderSource),HX_("vertexShaderSource",64,fb,81,44)},
	{::hx::fsString,(int)offsetof(Main_obj,fragmentShaderSource),HX_("fragmentShaderSource",d0,71,8a,f6)},
	{::hx::fsUnknown /*  PtWindow * */ ,(int)offsetof(Main_obj,window),HX_("window",f0,93,8c,52)},
	{::hx::fsUnknown /*  PtConfig * */ ,(int)offsetof(Main_obj,ptConfig),HX_("ptConfig",e6,87,32,da)},
	{::hx::fsUnknown /*  PtBackend * */ ,(int)offsetof(Main_obj,ptBackend),HX_("ptBackend",70,8a,52,fd)},
	{::hx::fsUnknown /*  GsBackend * */ ,(int)offsetof(Main_obj,backend),HX_("backend",14,bc,87,fb)},
	{::hx::fsUnknown /*  GsConfig * */ ,(int)offsetof(Main_obj,config),HX_("config",c2,56,d2,c7)},
	{::hx::fsUnknown /*  GsCommandList * */ ,(int)offsetof(Main_obj,commandList),HX_("commandList",49,bb,13,e5)},
	{::hx::fsUnknown /*  GsPipeline * */ ,(int)offsetof(Main_obj,pipeline),HX_("pipeline",22,bb,83,4b)},
	{::hx::fsUnknown /*  GsVtxLayout * */ ,(int)offsetof(Main_obj,layout),HX_("layout",aa,ae,b8,58)},
	{::hx::fsUnknown /*  GsProgram * */ ,(int)offsetof(Main_obj,program),HX_("program",84,4a,f9,f3)},
	{::hx::fsUnknown /*  GsShader * */ ,(int)offsetof(Main_obj,vertexShader),HX_("vertexShader",a9,b1,35,bd)},
	{::hx::fsUnknown /*  GsShader * */ ,(int)offsetof(Main_obj,fragmentShader),HX_("fragmentShader",15,4f,dc,39)},
	{::hx::fsUnknown /*  GsBuffer * */ ,(int)offsetof(Main_obj,vertexBuffer),HX_("vertexBuffer",84,af,a9,70)},
	{::hx::fsUnknown /*  GsBuffer * */ ,(int)offsetof(Main_obj,indexBuffer),HX_("indexBuffer",b2,65,a6,f5)},
	{::hx::fsBool,(int)offsetof(Main_obj,isActive),HX_("isActive",50,dd,af,6e)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

static ::String Main_obj_sMemberFields[] = {
	HX_("vertexData",ae,df,1f,d3),
	HX_("indexData",5c,0e,71,fe),
	HX_("vertexShaderSource",64,fb,81,44),
	HX_("fragmentShaderSource",d0,71,8a,f6),
	HX_("isActive",50,dd,af,6e),
	HX_("initWindow",20,ef,d1,56),
	HX_("destroyWindow",8a,2c,86,20),
	HX_("initGraphics",fb,7f,1e,b7),
	HX_("destroyGraphics",e5,6b,6c,84),
	HX_("frame",2d,78,83,06),
	HX_("loop",64,a6,b7,47),
	HX_("init",10,3b,bb,45),
	HX_("destroy",fa,2c,86,24),
	::String(null()) };

::hx::Class Main_obj::__mClass;

static ::String Main_obj_sStaticFields[] = {
	HX_("main",39,38,56,48),
	::String(null())
};

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Main_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Main_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Main_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

